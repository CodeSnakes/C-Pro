# 关于 C 标准

也许您经常听人们谈论 C89、C90、C99 之类的名字而不知道是什么东西。简单来说，这些就是 ANSI(美国国家标准局)不同年份制定的不同的国际标准，C99 就是 1999 年制定，C90 就是 1990 年制定，而 C89 就是 1989 年制定的咯。很明显 C99 要比 C89 要新很多，主要体现在支持了很多数据类型和新特性.

## 算法——程序的灵魂

程序=算法+数据结构

## 逻辑运算符

下表显示了 C++ 支持的关系逻辑运算符。

**假设变量 A 的值为 1，变量 B 的值为 0，则：**

运算符 描述 实例

| &&   | 称为逻辑与运算符 | 如果两个操作数都 true，则条件为 true                                   | (A && B) 为 false   |
| ---- | ---------------- | ---------------------------------------------------------------------- | ------------------- |
| \|\| | 称为逻辑或运算符 | 如果两个操作数中有任意一个 true                                        | 则条件为 true。 (A  |
| !    | 称为逻辑非运算符 | 用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false | !(A && B) 为 true。 |
|      |                  |                                                                        |                     |

## 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p   | q   | p & q | p \| q | p ^ q |
| :-- | :-- | :---- | :----- | :---- |
| 0   | 0   | 0     | 0      | 0     |
| 0   | 1   | 0     | 1      | 1     |
| 1   | 1   | 1     | 1      | 0     |
| 1   | 0   | 0     | 1      | 1     |

> 假设如果 **A = 60，且 B = 13**，现在以二进制格式表示，它们如下所示：
>
> A = 0011 1100
>
> B = 0000 1101

下表显示了 C 语言支持的位运算符。假设变量 **A** 的值为 60，变量 **B** 的值为 13，则：

| 运算符 | 描述                                                                                         | 实例                                                             |
| :----- | :------------------------------------------------------------------------------------------- | :--------------------------------------------------------------- | ------ | ------ | ----- | ---------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0; 0&1=0; 1&0=0; 1&1=1;`                  | (A & B) 将得到 12，即为 0000 1100                                |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0                                           | 0=0; 0                                                           | 1=1; 1 | 0=1; 1 | 1=1;` | (A \| B) 将得到 61，即为 0011 1101 |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0; 0^1=1; 1^0=1; 1^1=0;`                | (A ^ B) 将得到 49，即为 0011 0001                                |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2; ~0=1;`                               | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。 | A << 2 将得到 240，即为 1111 0000                                |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。     | A >> 2 将得到 15，即为 0000 1111                                 |

## 整型数据内存存放形式！

整型数据在内存中是以**其二进制的补码**的形式存放的！

**负数的补码是其反码加 1！**

### 1.原码

**就是以最高位作为符号位，0 代表该数值为正，1 代表为负！**

比如：67 和-67

![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20210408112819.png)

### 2.反码

正数的原码、反码、补码相同！

**负数的反码是在其符号位不变的基础之上，其余的数值位按位取反，就是 0 变成 1,1 变成 0**

![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20210408112839.png)

### 3.补码

正数的原码、反码、补码相同！

**负数的补码是其反码加 1！**

![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20210408113051.png)

```
也就是说，在内存中，67其实存放的就是：

00000000 00000000 00000000 01000011

而-67其实存放的就是：66+1

11111111 11111111 11111111 10111101
```



## 指针

### 值传递

  **说明:** C 语言调用函数时虚实结合的方法都是采用“值传递”方式，当用变量名作为
画数参数时传递的是变量的值，当用数组名作为函数参数时，由于数组名代表的是敏组首元
素地址，因此传递的值是地址，所以要求形参为指针变量。

> 在用数组名作为函数实参时,既然实际上相应的形参是指针变量，为什么还允许使用形
> 参数组的形式呢?这是因为在 C 语言中用下标法和指针法都可以访向一个数组(如果有一
> 个数组 a,则 a[门和\* (a+i)无条件等价),用下标法表示比较直观，便于理解。因此许多人
> 愿意用数组名作形参，以便与实参数组对应。从应用的角度看,用户可以认为有一个形参数
> 组，它从实参数组那里得到起始地址，因此形参数组与实参数组共占同一段内存单元,在调
> 用函数期间，如果改变了形参数组的值，也就是改变了实参数组的值。

**在主调函数中就可以利用这些已改变的值。对 C 语言比较熟练的专业人员往往喜欢用指针变量作形参。**

**注意:**实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是
一个固定的地址，而是按指针变量处理。