# 关于 C 标准

也许您经常听人们谈论 C89、C90、C99 之类的名字而不知道是什么东西。简单来说，这些就是 ANSI(美国国家标准局)不同年份制定的不同的国际标准，C99 就是 1999 年制定，C90 就是 1990 年制定，而 C89 就是 1989 年制定的咯。很明显 C99 要比 C89 要新很多，主要体现在支持了很多数据类型和新特性.

## 算法——程序的灵魂

程序=算法+数据结构

## 逻辑运算符

下表显示了 C++ 支持的关系逻辑运算符。

**假设变量 A 的值为 1，变量 B 的值为 0，则：**

运算符 描述 实例

| &&   | 称为逻辑与运算符 | 如果两个操作数都 true，则条件为 true                         | (A && B) 为 false   |
| ---- | ---------------- | ------------------------------------------------------------ | ------------------- |
| \|\| | 称为逻辑或运算符 | 如果两个操作数中有任意一个 true                              | 则条件为 true。 (A  |
| !    | 称为逻辑非运算符 | 用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false | !(A && B) 为 true。 |
|      |                  |                                                              |                     |

## 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

> 假设如果 **A = 60，且 B = 13**，现在以二进制格式表示，它们如下所示：
>
> A = 0011 1100
>
> B = 0000 1101

下表显示了 C 语言支持的位运算符。假设变量 **A** 的值为 60，变量 **B** 的值为 13，则：

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

## 整型数据内存存放形式！

整型数据在内存中是以**其二进制的补码**的形式存放的！

**负数的补码是其反码加1！**

### 1.原码

**就是以最高位作为符号位，0代表该数值为正，1代表为负！**

比如：67和-67

 ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20210408112819.png)

### 2.反码

正数的原码、反码、补码相同！

**负数的反码是在其符号位不变的基础之上，其余的数值位按位取反，就是0变成1,1变成0**

![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20210408112839.png)

 

###  3.补码

正数的原码、反码、补码相同！

**负数的补码是其反码加1！**

 ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20210408113051.png)

```
也就是说，在内存中，67其实存放的就是：

00000000 00000000 00000000 01000011

而-67其实存放的就是：66+1

11111111 11111111 11111111 10111101
```