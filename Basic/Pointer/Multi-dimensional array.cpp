/*通过指针引用多维数组*/
/*
   注意:不要把 &a[i] 简单地理解为 a[i] 元素的存储单元的地址，因为并不存在a[i] 
这样一个实际的教据存储单元。它只是一种地址的计算方法，能得到第i行的起始地址，
&a[i]和a[i]的值是一样的，但它们的基类型是不同的。
  
   &a[i]或a+i指向行，而且a[i]或*(a+i)指向列。
  
   当列下标j为0时,&a[i]和a[i](即a[i]+j)值相等,即它们的纯地址相
同，但应注意它们所指向的对象的类型是不同的，即指针的基类型是不同的。
*(a+i)只是a[i]的另一种表示形式，不要简单地认为 *(a+i) 是“a+i所指单元中的内容”。

在一维数组中a+i所指的是一个数组元素的存储单元，在该单元中有具体值，上述说法是正确的。
而对二维数组,a十i不是指向具体存储单元而是指向行(即指向一维数组)。

在二维数组中，a+i , a[i], *(a+i), &a[i], &a[i][O]的值相等，即它们都代表同一地址，但基类型不同。
请读者仔细琢磨其概念。

为了加深印象，更好地理解以上的概念,请分析和消化下面的例子。
*/
#include <stdio.h>
int main()
{
    void printNum(int *a);
    int a[3][4] = {
        {1, 3, 5, 7},
        {9, 11, 13, 15},
        {17, 19, 21, 23},
    };
    printNum(*a);
    /*   int a[3][4] = {1, 3, 5, 7 ,9, 11, 13, 15, 17, 19, 21, 23};*/
    printf("%d,%d\n", a, *a);                    //0行起始地址和0行0列元素地址
    printf("%d,%d\n", a[0], *(a + 0));           //0行0列元素地址
    printf("%d,%d\n", &a[0], &a[0][0]);          //0行起始地址和0行0列元素地址
    printf("%d,%d\n", a[1], a + 1);              //1行0列元素地址和1行起始地址
    printf("%d,%d\n", &a[1][0], *(a + 1) + 0);   //1行0列元素地址
    printf("%d,%d\n", a[2], *(a + 2));           //2行0列起始地址
    printf("%d,%d\n", &a[2], a + 2);             //2行起始地址
    printf("%d,%d\n", a[1][0], *(*(a + 1) + 0)); //1行0列元素的值
    printf("%d,%d\n", *a[2], *(*(a + 2) + 0));   //2行0列元素的值
    return 0;
    /*
    在不同的计算机、不同的编译环境、不同的时间运行以上程序时，
    由于分配内存情况不同，所显示的地址可能是不同的，但是上面显示的地址是有共同规律的
    */
}

void printNum(int *a)
{
    int *p;
    for (p = a; p < a + 12; p++)
    {
        if ((p - a) % 4 == 0)
        {
            printf("\n");
        }
        printf("%3d", *p);
    }
    printf("\n");
}